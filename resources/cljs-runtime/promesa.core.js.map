{"version":3,"sources":["promesa/core.cljc"],"mappings":"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","names":["promesa.core/resolved","v","promesa.impl/resolved","promesa.core/rejected","promesa.impl/rejected","promesa.core/deferred","promesa.impl/deferred","var_args","G__8332","promesa.core/promise","js/Error","promesa.protocols/-promise","executor","promesa.protocols/-map","cljs.core/identity","G__8338","promesa.core/create","f","d","e8339","G__8340","p1__8333#","G__8341","p1__8334#","promesa.protocols/-resolve!","promesa.protocols/-reject!","e","promesa.exec.run_BANG_","e8342","G__8343","p1__8335#","G__8344","p1__8336#","promesa.core/promise?","promesa.impl/*default-promise*","promesa.core/deferred?","promesa.core/thenable?","cljs.core/object?","cljs.core/fn?","promesa.core/resolved?","p","promesa.protocols/-resolved?","promesa.core/rejected?","promesa.protocols/-rejected?","promesa.core/pending?","promesa.protocols/-pending?","promesa.core/extract","promesa.protocols/-extract","promesa.core/done?","cljs.core/complement","promesa.core/wrap","G__8357","promesa.core/then","promesa.protocols/-then","G__8365","promesa.core/bind","G__8367","promesa.core/then'","G__8373","promesa.core/map","G__8377","promesa.core/mapcat","promesa.protocols/-bind","G__8390","promesa.core/chain","args-arr__4850__auto__","len__4829__auto__","i__4830__auto__","argseq__4851__auto__","cljs.core/IndexedSeq","seq8387","G__8388","cljs.core/first","cljs.core/next","G__8389","self__4816__auto__","promesa.core.then","fs","p1__8383#","p2__8384#","cljs.core.reduce","cljs.core/cons","G__8401","promesa.core/chain'","seq8398","G__8399","G__8400","promesa.core.then_SINGLEQUOTE_","G__8407","promesa.core/handle","promesa.protocols/-handle","G__8414","promesa.core/finally","promesa.protocols/-finally","G__8425","promesa.core/catch","promesa.protocols/-thenErr","pred-or-type","accept?","p1__8419#","cljs.core/ifn?","G__8436","promesa.core/catch'","promesa.protocols/-mapErr","p1__8430#","G__8452","promesa.core/error","promesa.core.catch$","type","promesa.core/err","promesa.core/all","promises","cljs.core.into_array","cljs.core/vec","promesa.core/race","cljs.core.map","G__8471","promesa.core/any","promesa.core.any","default","state","cljs.core.atom","cljs.core/count","promesa.core.create","resolve","reject","seq__8473","cljs.core/seq","chunk__8474","count__8475","i__8476","temp__5753__auto__","cljs.core/chunked-seq?","c__4649__auto__","cljs.core/chunk-first","cljs.core/chunk-rest","promesa.core.promise","cljs.core/deref","cljs.core.swap_BANG_","cljs.core.assoc","cljs.core.update","cljs.core/dec","cljs.core/conj","map__8504","cljs.core/--destructure-map","cljs.core.get","map__8511","resolved","counter","rejections","cljs.core/not","cljs.core._EQ_","G__8506","G__8514","cljs.core.ex_info","G__8524","promesa.core/run!","coll","promesa.core.run_BANG_","promesa.exec/current-thread-executor","p1__8517#","p2__8518#","_","promesa.core/cancel!","promesa.protocols/-cancel!","promesa.core/cancelled?","promesa.protocols/-cancelled?","G__8534","promesa.core/resolve!","o","promesa.core/reject!","promesa.core/promisify","callable","args","cljs.core.conj","e8544","cljs.core.apply","promesa.core/TimeoutException","message","it","goog/inherits","G__8553","promesa.core/timeout","t","promesa.core.timeout","promesa.exec/default-scheduler","scheduler","timeout","promesa.exec.schedule_BANG_","promesa.core.resolve_BANG_","G__8590","promesa.core/delay","promesa.core.delay","js/promesa","js/promesa.core","js/promesa.core.INTERNAL_LOOP_FN_NAME","promesa.core/INTERNAL_LOOP_FN_NAME","cljs.core.gensym"],"sourcesContent":[";; Copyright (c) 2015-2019 Andrey Antukh <niwi@niwi.nz>\n;; All rights reserved.\n;;\n;; Redistribution and use in source and binary forms, with or without\n;; modification, are permitted provided that the following conditions\n;; are met:\n;;\n;; 1. Redistributions of source code must retain the above copyright\n;;    notice, this list of conditions and the following disclaimer.\n;; 2. Redistributions in binary form must reproduce the above copyright\n;;    notice, this list of conditions and the following disclaimer in the\n;;    documentation and/or other materials provided with the distribution.\n;;\n;; THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n;; IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n;; OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n;; IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,\n;; INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n;; NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n;; DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n;; THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n;; (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n;; THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n(ns promesa.core\n  (:refer-clojure :exclude [delay spread promise\n                            await map mapcat run!\n                            future let loop recur])\n  (:require\n   [promesa.protocols :as pt]\n   [clojure.core :as c]\n   [promesa.exec :as exec]\n   [promesa.impl :as impl])\n  #?(:cljs (:require-macros [promesa.core]))\n  #?(:clj\n     (:import\n      java.util.concurrent.CompletableFuture\n      java.util.concurrent.CompletionStage\n      java.util.concurrent.TimeoutException)))\n\n;; --- Promise\n\n(defn resolved\n  \"Return a resolved promise with provided value.\"\n  [v]\n  (impl/resolved v))\n\n(defn rejected\n  \"Return a rejected promise with provided reason.\"\n  [v]\n  (impl/rejected v))\n\n(defn deferred\n  \"Creates an empty promise instance.\"\n  []\n  (impl/deferred))\n\n(defn promise\n  \"The coerce based promise constructor. Creates a appropriate promise\n  instance depending on the provided value.\n\n  If an executor is provided, it will be used to resolve this\n  promise.\"\n  ([v] (pt/-promise v))\n  ([v executor]\n   (pt/-map v identity executor)))\n\n(defn create\n  \"Create a promise instance from a factory function. If an executor is\n  provided, the factory will be executed in the provided executor.\n\n  A factory function looks like `(fn [resolve reject] (resolve 1))`.\"\n  ([f]\n   (c/let [d (impl/deferred)]\n     (try\n       (f #(pt/-resolve! d %)\n          #(pt/-reject! d %))\n       (catch #?(:clj Exception :cljs :default) e\n         (pt/-reject! d e)))\n     d))\n  ([f executor]\n   (c/let [d (impl/deferred)]\n     (exec/run! executor (fn []\n                           (try\n                             (f #(pt/-resolve! d %)\n                                #(pt/-reject! d %))\n                             (catch #?(:clj Exception :cljs :default) e\n                               (pt/-reject! d e)))))\n     d)))\n\n(defn promise?\n  \"Return true if `v` is a promise instance.\"\n  [v]\n  #?(:clj (instance? CompletionStage v)\n     :cljs (instance? impl/*default-promise* v)))\n\n(defn deferred?\n  \"Return true if `v` is a promise instance (alias to `promise?`.\"\n  [v]\n  #?(:clj (instance? CompletionStage v)\n     :cljs (instance? impl/*default-promise* v)))\n\n#?(:cljs\n   (defn thenable?\n     \"Returns true if `v` is a promise like object.\"\n     [v]\n     (and (object? v) (fn? (unchecked-get v \"then\")))))\n\n;; Predicates\n\n(defn resolved?\n  \"Returns true if promise `p` is already fulfilled.\"\n  [p]\n  (pt/-resolved? p))\n\n(defn rejected?\n  \"Returns true if promise `p` is already rejected.\"\n  [p]\n  (pt/-rejected? p))\n\n(defn pending?\n  \"Returns true if promise `p` is stil pending.\"\n  [p]\n  (pt/-pending? p))\n\n(defn extract\n  \"Returns the current promise value.\"\n  [p]\n  (pt/-extract p))\n\n(def done?\n  \"Returns true if promise `p` is already done.\"\n  (complement pending?))\n\n;; Chaining\n\n(defn wrap\n  [v]\n  (if (promise? v)\n    v\n    (pt/-promise v)))\n\n(defn then\n  \"Chains a computation `f` (function) to be executed when the promise\n  `p` is successfully resolved.\n\n  The computation will be executed in the calling thread by default;\n  you also can provide a custom executor.\n\n  If the function `f` returns a promise instance, it will be\n  automatically unwrapped.\"\n  ([p f]\n   (pt/-then p f))\n  ([p f executor]\n   (pt/-then p f executor)))\n\n(defn bind\n  \"A convenient alias for `then`.\"\n  ([p f]\n   (pt/-then p f))\n  ([p f executor]\n   (pt/-then p f executor)))\n\n(defn then'\n  \"Chains a computation `f` (function) to be executed when the promise\n  `p` is successfully resolved.\n\n  The computation will be executed in the calling thread by default;\n  you also can provide a custom executor.\n\n  Don't perform flatten on the result.\"\n  ([p f] (pt/-map p f))\n  ([p f executor] (pt/-map p f executor)))\n\n(defn map\n  \"Chains a computation `f` (function) to be executed when the promise\n  `p` is successfully resolved.\n\n  Unlike `then` this does not performs automatic promise flattening.\n  This is designed to be used with `->>`.\"\n  ([f p] (pt/-map p f))\n  ([executor f p] (pt/-map p f executor)))\n\n(defn mapcat\n  \"Chains a computation `f` (function) to be executed when the promise\n  `p` is successfully resolved. always expecting that `f` returns a\n  promise that will be automatically unwrapped.\n\n  This is just a stricter version of `then` with reversed arguments in\n  the same way as `map`.\n\n  This is designed to be used with `->>`.\"\n  ([f p] (pt/-bind p f))\n  ([executor f p] (pt/-bind p f executor)))\n\n(defn chain\n  \"Chain variable number of computations to be executed\n  serially. Analogous to `then` that accepts variable number of\n  functions.\"\n  ([p f] (then p f))\n  ([p f & fs] (reduce #(then %1 %2) p (cons f fs))))\n\n(defn chain'\n  \"Chain variable number of computations to be executed serially. Unlike\n  `chain` does not flattens the return value of each step (probably\n  this is more performant than `chain`).\"\n  ([p f] (then' p f))\n  ([p f & fs] (reduce pt/-map p (cons f fs))))\n\n(defn handle\n  \"Executes `f` when the promise `p` is resolved or is rejected. Returns\n  a promise resolved with the return value of `f` function.\"\n  ([p f] (pt/-handle p f))\n  ([p f executor] (pt/-handle p f executor)))\n\n(defn finally\n  \"Attach a potentially side-effectful handler to promise that will be\n  executed independently if promise is resolved or rejected.\n\n  Returns the original promise and the return value of `f` function is\n  ignored.\"\n  ([p f] (pt/-finally p f))\n  ([p f executor] (pt/-finally p f executor)))\n\n(defn catch\n  \"Executes `f` when the promise `p` is rejected. Returns a promise\n  resolved with the return value of `f` function handler.\"\n  ([p f]\n   (pt/-thenErr p f))\n  ([p pred-or-type f]\n   (c/let [accept? (if (ifn? pred-or-type)\n                     pred-or-type\n                     #(instance? pred-or-type %))]\n     (pt/-thenErr p (fn [e]\n                      (if (accept? e)\n                        (f e)\n                        (impl/rejected e)))))))\n\n(defn catch'\n  \"Executes `f` when the promise `p` is rejected. Returns a promise\n  resolved with the return value of `f` function handler.\"\n  ([p f]\n   (pt/-mapErr p f))\n  ([p pred-or-type f]\n   (c/let [accept? (if (ifn? pred-or-type)\n                     pred-or-type\n                     #(instance? pred-or-type %))]\n     (pt/-mapErr p (fn [e]\n                     (if (accept? e)\n                        (f e)\n                        (throw e)))))))\n\n(defn error\n  \"Same as `catch` but with parameters inverted.\"\n  ([f p] (catch p f))\n  ([f type p] (catch p type f)))\n\n(def err\n  \"A short alias for `error` function.\"\n  error)\n\n(defn all\n  \"Given an array of promises, return a promise\n  that is fulfilled  when all the items in the\n  array are fulfilled.\n\n  Example:\n\n  (-> (all [(promise :first-promise)\n            (promise :second-promise)]\n      (then (fn [[first-result second-result]]))\n       (println (str first-result \\\", \\\" second-result)\n\n  Will print out\n  :first-promise, :second-promise.\n\n  If at least one of the promises is rejected, the resulting promise will be\n  rejected.\"\n  [promises]\n  #?(:cljs (-> (.all impl/*default-promise* (into-array promises))\n               (then' vec))\n     :clj (c/let [promises (clojure.core/map pt/-promise promises)]\n            (then' (->> (into-array CompletableFuture promises)\n                        (CompletableFuture/allOf))\n                   (fn [_]\n                     (mapv pt/-extract promises))))))\n\n(defn race\n  [promises]\n  #?(:cljs (.race impl/*default-promise* (into-array (cljs.core/map pt/-promise promises)))\n     :clj (CompletableFuture/anyOf (->> (clojure.core/map pt/-promise promises)\n                                        (into-array CompletableFuture)))))\n\n(defn any\n  \"Given an array of promises, return a promise that is fulfilled when\n  first one item in the array is fulfilled.\"\n  ([promises]\n   (any promises ::default))\n  ([promises default]\n   (c/let [state (atom {:resolved false\n                      :counter (count promises)\n                      :rejections []})]\n     (create\n      (fn [resolve reject]\n        (doseq [p promises]\n          (-> (promise p)\n              (then (fn [v]\n                      (when-not (:resolved @state)\n                        (swap! state (fn [state]\n                                       (-> state\n                                           (assoc :resolved true)\n                                           (update :counter dec))))\n                        (resolve v))))\n              (catch (fn [e]\n                       (swap! state (fn [state]\n                                      (-> state\n                                          (update  :counter dec)\n                                          (update :rejections conj e))))\n                       (c/let [{:keys [resolved counter rejections]} @state]\n                         (when (and (not resolved) (= counter 0))\n                           (if (= default ::default)\n                             (reject (ex-info \"No promises resolved\"\n                                              {:rejections rejections}))\n                             (resolve default)))))))))))))\n\n(defn run!\n  \"A promise aware run! function.\"\n  ([f coll] (run! f coll exec/current-thread-executor))\n  ([f coll executor] (reduce #(then %1 (fn [_] (f %2))) (promise nil executor) coll)))\n\n;; Cancellation\n\n(defn cancel!\n  \"Cancel the promise.\"\n  [p]\n  (pt/-cancel! p)\n  p)\n\n(defn cancelled?\n  \"Return true if `v` is a cancelled promise.\"\n  [v]\n  (pt/-cancelled? v))\n\n;; Completable\n\n(defn resolve!\n  \"Resolve a completable promise with a value.\"\n  ([o] (pt/-resolve! o nil))\n  ([o v] (pt/-resolve! o v)))\n\n(defn reject!\n  \"Reject a completable promise with an error.\"\n  [p e]\n  (pt/-reject! p e))\n\n;; --- Utils\n\n(defn promisify\n  \"Given a function that accepts a callback as the last argument return other\n  function that returns a promise. Callback is expected to take single\n  parameter (result of a computation).\"\n  [callable]\n  (fn [& args]\n    (create (fn [resolve reject]\n               (c/let [args (-> (vec args) (conj resolve))]\n                 (try\n                   (apply callable args)\n                   (catch #?(:clj Throwable :cljs js/Error) e\n                     (reject e))))))))\n\n#?(:cljs\n   (defn ^{:jsdoc [\"@constructor\"]}\n     TimeoutException [message]\n     (this-as it\n       (.call js/Error it message {} nil)\n       it)))\n\n#?(:cljs (goog/inherits TimeoutException js/Error))\n\n(defn timeout\n  \"Returns a cancellable promise that will be fulfilled with this\n  promise's fulfillment value or rejection reason.  However, if this\n  promise is not fulfilled or rejected within `ms` milliseconds, the\n  returned promise is cancelled with a TimeoutError\"\n  ([p t] (timeout p t ::default exec/default-scheduler))\n  ([p t v] (timeout p t v exec/default-scheduler))\n  ([p t v scheduler]\n   (c/let [timeout (deferred)]\n     (exec/schedule! scheduler t #(if (= v ::default)\n                                    (reject! timeout (TimeoutException. \"Operation timed out.\"))\n                                    (resolve! timeout v)))\n     (race [p timeout]))))\n\n(defn delay\n  \"Given a timeout in miliseconds and optional\n  value, returns a promise that will fulfilled\n  with provided value (or nil) after the\n  time is reached.\"\n  ([t] (delay t nil exec/default-scheduler))\n  ([t v] (delay t v exec/default-scheduler))\n  ([t v scheduler]\n   (c/let [d (deferred)]\n     (exec/schedule! scheduler t #(resolve! d v))\n     d)))\n\n#?(:clj\n   (defmacro do!\n     \"Execute potentially side effectful code and return a promise\n     resolved to the last expression. Always awaiting the result of each\n     expression.\"\n     [& exprs]\n     `(pt/-bind nil (fn [_#]\n                      ~(condp = (count exprs)\n                         0 `(pt/-promise nil)\n                         1 `(pt/-promise ~(first exprs))\n                         (reduce (fn [acc e]\n                                   `(pt/-bind ~e (fn [_#] ~acc)))\n                                 `(pt/-promise ~(last exprs))\n                                 (reverse (butlast exprs))))))))\n\n#?(:clj\n   (defmacro let\n     \"A `let` alternative that always returns promise and waits for\n     all the promises on the bindings.\"\n     [bindings & body]\n     `(pt/-bind nil (fn [_#]\n                      ~(->> (reverse (partition 2 bindings))\n                            (reduce (fn [acc [l r]]\n                                      `(pt/-bind ~r (fn [~l] ~acc)))\n                                    `(do! ~@body)))))))\n\n#?(:clj (def #^{:macro true :doc \"A backward compatibility alias for `let`.\"}\n          alet #'let))\n\n\n#?(:clj\n   (defmacro plet\n     \"A parallel let; executes all the bindings in parallel and\n     when all bindings are resolved, executes the body.\"\n     [bindings & body]\n     `(pt/-bind nil (fn [_#]\n                      ~(c/let [bindings (partition 2 bindings)]\n                         `(-> (all ~(mapv second bindings))\n                              (then (fn [[~@(mapv first bindings)]]\n                                      (do! ~@body)))))))))\n\n#?(:clj\n   (defmacro future\n     \"Analogous to `clojure.core/future` that returns a promise instance\n     instead of the `Future`. Usefull for execute synchronous code in a\n     separate thread (also works in cljs).\"\n     [& body]\n     `(-> (exec/submit! (fn []\n                          (c/let [f# (fn [] ~@body)]\n                            (pt/-promise (f#)))))\n          (pt/-bind identity))))\n\n\n(defonce ^:private INTERNAL_LOOP_FN_NAME\n  (gensym 'internal-loop-fn-name))\n\n(defmacro loop\n  \"Analogous to `clojure.core/loop`.\"\n  [bindings & body]\n  (c/let [bindings (partition 2 2 bindings)\n          names (mapv first bindings)\n          fvals (mapv second bindings)\n          syms (mapv gensym names)]\n    `(do!\n      (letfn [(~INTERNAL_LOOP_FN_NAME [~@syms]\n               (-> (p/all [~@syms])\n                   (p/then (fn [[~@names]] (do! ~@body)))))]\n        (~INTERNAL_LOOP_FN_NAME ~@fvals)))))\n\n(defmacro recur\n  [& args]\n  `(~INTERNAL_LOOP_FN_NAME ~@args))\n"]}