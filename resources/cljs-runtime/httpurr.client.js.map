{"version":3,"sources":["httpurr/client.cljc"],"mappings":";AAQA,oCAAA,2CAAA,qDAAA,OAAA,yDAAA,UAAA,mDAAA,MAAA,oDAAA,OAAA,mDAAA,MAAA,sDAAA,QAAA,0DAAA,SAAA,wDAAA,pjBAAKA;AAUL,+BAAA,/BAAOC,sEACJC,OAAOC,QAAQC;AADlB,AAEE,IAAAC,YAAuEF;IAAvEE,gBAAA,AAAAC,4BAAAD;aAAA,AAAAE,4CAAAF,cAAA,uDAAA,1HAAcG;UAAd,AAAAD,4CAAAF,cAAA,hEAAqBI;cAArB,AAAAF,4CAAAF,cAAA,pEAAyBK;WAAzB,AAAAH,4CAAAF,cAAA,jEAAiCM;mBAAjC,AAAAJ,4CAAAF,cAAA,zEAAsCO;AAAtC,AACE,OAACC,wBAAYX,OAAOC,QAAQC;;AAEhC;;;;;;qCAAA,rCAAMU,kFAKHX;AALH,AAME,OAACY,kDACA,WAAKC,QAAQC;AAAb,AACE,OAACC,0BAAcf,QACA,WAAKgB;AAAL,AACE,oBAAI,AAACC,kCAAgBD;AACnB,IAAAE,UAAS,AAACC,4BAAgBH;AAA1B,AAAA,sFAAAE,6BAAAA,3GAACL,wCAAAA,iDAAAA;;AACD,IAAAO,UAAQ,AAACC,yBAAaL;AAAtB,AAAA,oFAAAI,4BAAAA,xGAACN,uCAAAA,gDAAAA;;;;;AAEzB,AAAA;;;;;;;;;;;;4BAAA,oCAAAQ,hEAAME;AAAN,AAAA,IAAAD,UAAA,AAAA;AAAA,AAAA,QAAAA;KAAA;AAAA,OAAAC,wDAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;KAAA;AAAA,OAAAA,wDAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;;AAAA,MAAA,KAAAC,MAAA,CAAA,8DAAA,AAAA;;;;;AAAA,CAAA,0DAAA,1DAAMD,qEAWFzB,OAAOC;AAXX,AAYG,8EAAA,vEAAC0B,wDAAM3B,OAAOC;;;AAZjB,CAAA,0DAAA,1DAAMwB,qEAaFzB,OAAOC,QAAQC;AAbnB,AAcG,IAAMD,cAAQ,AAACF,6BAASC,OAAOC,QAAQC;AAAvC,AACE,OAACU,mCAAiBX;;;AAfvB,CAAA,oDAAA,pDAAMwB;;AAAN,AAmBA,wBAAA,xBAAMG,wDACHC;AADH,AAEE;;4BACI7B,OAAOO;AADX,AAEG,sEAAA,2CAAA,yDAAA,nKAACoB,wDAAM3B,yGAAgB6B,oDAAOtB;;4BAC7BP,OAAOO,IAAIuB;AAHf,AAIG,OAACH,wDAAM3B,OAAO,2GAAA,2CAAA,yDAAA,/MAAC+B,uGAAMD,sGAAaD,oDAAOtB;;4BACxCP,OAAOO,IAAIuB,IAAIE;AALnB,AAMG,OAACL,wDAAM3B,OAAO,2GAAA,2CAAA,yDAAA,/MAAC+B,uGAAMD,sGAAaD,oDAAOtB,kBAAMyB;;mBAD9ChC,OAAOO,IAAIuB,IAAIE;;;4BAAfhC,OAAOO;;4BAAPP,OAAOO,IAAIuB;;4BAAX9B,OAAOO,IAAIuB,IAAIE;;;;;;;;;;AAGrB,AAAKC,sBAAQ,sBAAA,tBAACL;AACd,AAAKM,yBAAQ,sBAAA,tBAACN;AACd,AAAKO,qBAAQ,sBAAA,tBAACP;AACd,AAAKQ,sBAAQ,sBAAA,tBAACR;AACd,AAAKS,qBAAQ,sBAAA,tBAACT;AACd,AAAKU,uBAAQ,sBAAA,tBAACV;AACd,AAAKW,yBAAQ,sBAAA,tBAACX;AACd,AAAKY,uBAAQ,sBAAA,tBAACZ","names":["httpurr.client/keyword->method","httpurr.client/perform!","client","request","options","map__8605","cljs.core/--destructure-map","cljs.core.get","method","url","headers","body","query-string","httpurr.protocols/-send","httpurr.client/request->promise","promesa.core.create","resolve","reject","httpurr.protocols/-listen","resp","httpurr.protocols/-success?","G__8613","httpurr.protocols/-response","G__8614","httpurr.protocols/-error","var_args","G__8619","httpurr.client/send!","js/Error","httpurr.client.send_BANG_","httpurr.client/method","m","req","cljs.core.merge","opts","httpurr.client/head","httpurr.client/options","httpurr.client/get","httpurr.client/post","httpurr.client/put","httpurr.client/patch","httpurr.client/delete","httpurr.client/trace"],"sourcesContent":["(ns httpurr.client\n  \"The HTTP client. This namespace provides a low-level `send!` primitive for\n  performing requests as well as aliases for all the HTTP methods.\"\n  (:refer-clojure :exclude [get])\n  (:require [promesa.core :as p]\n            [httpurr.protocols :as proto])\n  #?(:clj (:import java.net.URL) :cljs (:import goog.Uri)))\n\n(def keyword->method\n  {:head    \"HEAD\"\n   :options \"OPTIONS\"\n   :get     \"GET\"\n   :post    \"POST\"\n   :put     \"PUT\"\n   :patch   \"PATCH\"\n   :delete  \"DELETE\"\n   :trace   \"TRACE\"})\n\n(defn- perform!\n  [client request options]\n  (let [{:keys [method url headers body query-string] :or {method :get}} request]\n    (proto/-send client request options)))\n\n(defn request->promise\n  \"Given a object that implements `httpurr.protocols.Request`,\n  return a promise that will be resolved if there is a\n  response and rejected on timeout, exceptions, HTTP errors\n  or abortions.\"\n  [request]\n  (p/create\n   (fn [resolve reject]\n     (proto/-listen request\n                    (fn [resp]\n                      (if (proto/-success? resp)\n                        (resolve (proto/-response resp))\n                        (reject (proto/-error resp))))))))\n\n(defn send!\n  \"Given a request map and maybe an options map, perform\n  the request and return a promise that will be resolved\n  when receiving the response.\n\n  If the request timeouts, throws an exception or is aborted\n  the promise will be rejected.\n\n  The available options are:\n     - `:timeout`: a timeout for the request in miliseconds\n  \"\n  ([client request]\n   (send! client request {}))\n  ([client request options]\n   (let [request (perform! client request options)]\n     (request->promise request))))\n\n;; facade\n\n(defn method\n  [m]\n  (fn\n    ([client url]\n     (send! client {:method m :url url}))\n    ([client url req]\n     (send! client (merge req {:method m :url url})))\n    ([client url req opts]\n     (send! client (merge req {:method m :url url}) opts))))\n\n(def head    (method :head))\n(def options (method :options))\n(def get     (method :get))\n(def post    (method :post))\n(def put     (method :put))\n(def patch   (method :patch))\n(def delete  (method :delete))\n(def trace   (method :trace))\n"]}